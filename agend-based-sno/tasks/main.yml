# tasks file for agend-based-sno
---
# Everything for a clean installation of the same cluster
- name: "CLEAN: Clean Cluster directories for a fresh installation"
  ansible.builtin.file:
    path: "{{ item }}"
    state: absent
  loop:
    - "{{ ssh_key_dir }}"
    - "{{ cluster_dir }}"
    - "{{ network_dir}}"

# Remove ISO-File if exists, because of a new fresh installation
- name: "CLEAN: Delete the iso-file"
  ansible.builtin.file:
    path: "{{ dir_downloads }}{{ cluster_name }}.iso"
    state: absent

- name: "ENVIRONMENT: Create some base directories"
  ansible.builtin.file:
    path: "{{ item }}"
    state: directory
    mode: '0644'
  loop:
    - "{{ base_dir }}"
    - "{{ base_dir }}ssh-keys"
    - "{{ base_dir }}sno-clusters"
    - "{{ base_dir }}downloads"
    - "{{ base_dir }}certs"
    - "{{ ssh_key_dir }}"
    - "{{ cluster_dir }}"
    - "{{ network_dir }}"
    - "/root/.cache/agent/image_cache/"

- name: "ENVIRONMENT: Create SSH directory if it does not exist"
  ansible.builtin.file:
    path: "{{ ssh_key_dir }}"
    state: directory
    mode: '0755'

# - name: Verify Nginx and Artifactory service availability
#   uri:
#     url: "https://{{ container_image_registry_root }}/ui/login/"
#     method: GET
#     return_content: no
#     validate_certs: false
#   register: artifactory_response
#   failed_when: artifactory_response.status not in [200, 502, 503]

# - name: Debug Artifactory service response
#   debug:
#     msg: "Artifactory is running. Status code: {{ artifactory_response.status }}"
#   when: artifactory_response.status == 200

# - name: Handle Bad Gateway (502) error
#   fail:
#     msg: 
#       - "Artifactory returned 502 Bad Gateway."
#       - "Bitte prüfe die NGINX-Konfiguration oder Artifactory-Verfügbarkeit."
#       - "systemctl status nginx"
#       - "systemctl status artifactory"
#       - "Bitte vergiss nicht die beiden Dienste zu starten!"
#   when: artifactory_response.status == 502

# - name: Handle Service Unavailable (503) error
#   fail:
#     msg: 
#       - "Artifactory returned 503 Service Unavailable."
#       - "Bitte prüfe, ob dein Artifactory-Server läuft...!!!"
#   when: artifactory_response.status == 503

# - name: Fail if Artifactory is not running
#   fail:
#     msg: 
#       - "Artifactory ist nicht erreichbar. Status code: {{ artifactory_response.status }}"
#       - "Bitte prüfe, ob Nginx und Artifactory laufen"
#   when: artifactory_response.status not in [200, 502, 503]

- name: "SSH-KEYS: Generate SSH key if not exists"
  ansible.builtin.command:
    cmd: "ssh-keygen -f {{ ssh_key_dir }}/id_rsa_{{ cluster_name }} -N ''"
  args:
    creates: "{{ ssh_key_dir }}/id_rsa_{{ cluster_name }}.pub"

- name: "SSH-KEYS: Check if SSH public key exists on remote server"
  ansible.builtin.stat:
    path: "{{ ssh_key_dir }}/id_rsa_{{ cluster_name }}.pub"
  register: ssh_key_stat

- name: "SSH-KEYS: Fail if SSH public key does not exist"
  ansible.builtin.fail:
    msg: "The SSH public key {{ ssh_key_dir }}/id_rsa_{{ cluster_name }}.pub was not found on the remote server."
  when: not ssh_key_stat.stat.exists

- name: "SSH-KEYS: Read SSH public key from remote server"
  ansible.builtin.slurp:
    src: "{{ ssh_key_dir }}/id_rsa_{{ cluster_name }}.pub"
  register: ssh_key_content
  when: ssh_key_stat.stat.exists

- name: "SSH-KEYS: Decode SSH public key content"
  ansible.builtin.set_fact:
    ssh_public_key: "{{ ssh_key_content.content | b64decode | trim }}"
  when: ssh_key_stat.stat.exists

# Template install-config.yaml
- name: "OPENSHIFT: Template install-config.yaml in cluster directory"
  ansible.builtin.template:
    src: install-config.yaml.j2
    dest: "{{ cluster_dir }}/install-config.yaml"
    mode: '0644'

- name: "OPENSHIFT: Template agent-config.yaml in cluster directory"
  ansible.builtin.template:
    src: agent-config-with-network.yaml.j2
    dest: "{{ cluster_dir }}/agent-config.yaml"
    mode: '0644'

# Backup -install-config.yaml
- name: "OPENSHIFT: Make a copy of install-config.yaml to shared directory (install-config-{{ cluster_name }}.yaml)"
  ansible.builtin.template:
    src: "install-config.yaml.j2"
    dest: "{{ base_dir }}/sno-clusters/install-config-{{ cluster_name }}.yaml"
    mode: '0644'

- name: "OPENSHIFT: Make a copy of agent-config.yaml to shared directory (install-config-{{ cluster_name }}.yaml)"
  ansible.builtin.template:
    src: "agent-config-with-network.yaml.j2"
    dest: "{{ base_dir }}/sno-clusters/agent-config-{{ cluster_name }}.yaml"
    mode: '0644'


# Generate Zero-Touch-Provisioning YAML to cluster-dir
# openshift-install agent create cluster-manifests --dir <installation_directory>
- name: "OPENSHIFT-INSTALL: Create Cluster-Manifests-Directory for Zero-Touch-Provisioning"
  ansible.builtin.shell: "/usr/local/bin/openshift-install --dir={{ base_dir }}sno-clusters/{{ cluster_name }} agent create cluster-manifests"
  environment:
    PATH: "/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:{{ base_dir }}downloads"
    # PATH: "/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:{{ base_dir }}downloads/openshift-install:{{ base_dir }}downloads/oc"




# INSERT ZTP Yaml-Files to customize the SNO-Installation

- name: "OPENSHIFT-INSTALL: Create Agent-Based-ISO"
  ansible.builtin.shell: "/usr/local/bin/openshift-install --dir={{ base_dir }}sno-clusters/{{ cluster_name }} agent create image"
  environment:
    PATH: "/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:{{ base_dir }}downloads"
    # PATH: "/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:{{ base_dir }}downloads/openshift-install:{{ base_dir }}downloads/oc"

# # Download -Zertifate vom vCenter
# - name: "BASTION: Download vCenter-Root-Certificates to Bastion-Host"
#   ansible.builtin.get_url:
#     url: "https://{{ vcenter_hostname }}/certs/download.zip"
#     dest: "{{ dir_downloads }}download.zip"
#     mode: '0600'
#     validate_certs: false
#   register: download_result

# # Extract Root-Certificates
# - name: "BASTION: Extract Root-Certificates to Bastion-Host certs-directory"
#   ansible.builtin.unarchive:
#     src: "{{ dir_downloads }}download.zip"
#     dest: "{{ dir_certs }}"
#     remote_src: true
#   when: download_result is succeeded

# # Copy root-cafile to truststore on Bastion-Host
# - name: "BASTION: Copy all vcenter-rootca-certificate-files to the bastions truststore"
#   ansible.builtin.copy:
#     src: "{{ dir_entpackt }}"
#     dest: "/etc/pki/ca-trust/source/anchors/"
#     owner: root
#     group: root
#     mode: '0644'
#     remote_src: true

# # Refresh the truststore of the Bastion-Host
# - name: "BASTION: Refresh Bastion-Host CA-Truststore"
#   ansible.builtin.command: update-ca-trust
#   changed_when: false

### VMWARE
# Löschen falls vorhanden
- name: "VMWARE: Delete an existing virtual machine, if exists"
  community.vmware.vmware_guest:
    hostname: "{{ vcenter_hostname }}"
    username: "{{ vcenter_username }}"
    password: "{{ vcenter_password }}"
    name: "{{ cluster_name }}"
    delete_from_inventory: true
    state: absent
    force: true
  # delegate_to: localhost

# # WICHTIG: Das ISO-File darf nicht mehr in einer VM gemounted sein!!!
# - name: "VMWARE: Remove {{ cluster_name}}.iso on a datastore before uploading"
#   community.vmware.vsphere_file:
#     hostname: '{{ esx_host_hostname }}'
#     username: '{{ esx_host_username }}'
#     password: '{{ esx_host_password }}'
#     datacenter: ha-datacenter
#     datastore: local-ssd
#     path: sno/{{ cluster_name }}.iso
#     state: absent

# # Upload to Datastore
# - name: "VMWARE: Upload customized-sno ISO to VMware datastore via HTTPS"
#   ansible.builtin.uri:
#     url: "https://{{ esx_host_hostname }}/folder/sno/{{ cluster_name }}.iso?dcPath=ha-datacenter&dsName=local-ssd"
#     method: PUT
#     user: "{{ esx_host_username }}"
#     password: "{{ esx_host_password }}"
#     # sno2/agent.x86_64.iso
#     src: "{{ cluster_dir }}{{filename_agent_iso}}"
#     force_basic_auth: true
#     status_code: 201
#     remote_src: true

# Check if ISO exists in Content Library and then delete
- name: Check if the ISO file exists in the Content Library
  shell: |
    govc library.ls /iso-library/sno1.iso || echo "not_exists"
  environment:
    GOVC_URL: "https://{{ vcenter_hostname }}/sdk"
    GOVC_USERNAME: "{{ vcenter_username }}"
    GOVC_PASSWORD: "{{ vcenter_password }}"
    GOVC_INSECURE: "0"  # Setzt SSL-Zertifikatüberprüfung außer Kraft, falls du selbstsignierte Zertifikate verwendes
    PATH: "/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:{{ base_dir }}downloads/"
  register: iso_check
  changed_when: false

- name: Delete the ISO file if it exists
  shell: govc library.rm /iso-library/sno1.iso
  environment:
    GOVC_URL: "https://{{ vcenter_hostname }}/sdk"
    GOVC_USERNAME: "{{ vcenter_username }}"
    GOVC_PASSWORD: "{{ vcenter_password }}"
    GOVC_INSECURE: "0"  # Setzt SSL-Zertifikatüberprüfung außer Kraft, falls du selbstsignierte Zertifikate verwendes
    PATH: "/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:{{ base_dir }}downloads/"
  # when: iso_check.stdout != "not_exists"
  when: "'/iso-library/sno1.iso' in iso_check.stdout"
  register: delete_result





# Upload to Content Library
# govc library.upload -library="${LIBRARY_NAME}" "${ISO_PATH}"
- name: "GOVC: Upload customized-sno ISO to VMware Content Library"
  # govc library.import -n="sno1.iso" /iso-library /opt/sva/sno-clusters/sno1/agent.x86_64.iso
  ansible.builtin.shell: "govc library.import -n={{ cluster_name }}.iso /{{ content_library_name }} {{ cluster_dir }}{{ filename_agent_iso }}"
  environment:
    GOVC_URL: "https://{{ vcenter_hostname }}/sdk"
    GOVC_USERNAME: "{{ vcenter_username }}"
    GOVC_PASSWORD: "{{ vcenter_password }}"
    GOVC_INSECURE: "0"  # Setzt SSL-Zertifikatüberprüfung außer Kraft, falls du selbstsignierte Zertifikate verwendes
    PATH: "/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:{{ base_dir }}downloads/"
  tags:
    - customattribut


# Erzeuge eine VM für SNO
# !!!disk.EnableUUID=TRUE mit einbauen!!!

## USING ISO-Datastore
# - name: "VMWARE: Create the virtual machine for SNO"
#   community.vmware.vmware_guest:
#     hostname: "{{ vcenter_hostname }}"
#     username: "{{ vcenter_username }}"
#     password: "{{ vcenter_password }}"
#     datacenter: "dc-home"
#     folder: /dc-home/vm/openshift/
#     name: "{{ cluster_name }}"
#     state: powered-off
#     guest_id: rhel9_64Guest
#     # This is hostname of particular ESXi server on which user wants VM to be deployed
#     # esxi_hostname: "{{ esxi_hostname }}"
#     # customvalues:
#     #   - key: disk.EnableUUID   # add the Advanced Configuration Parameter 
#     #     value: TRUE
#     disk:
#     - size_gb: "{{ disk_size_gb }}"
#       type: thin
#       datastore: "{{ datastore }}"
#     hardware:
#       memory_mb: "{{ memory_mb }}"
#       num_cpus: "{{ cpu_count }}"
#     cdrom:
#       - controller_type: sata
#         controller_number: 0
#         unit_number: 1
#         state: present
#         type: iso
#         iso_path: "[local-ssd] sno/{{ cluster_name }}.iso"
#     networks:
#     - name: "{{ network_name }}"
#       device_type: vmxnet3
#       mac: "{{ mac_address }}"
#     # wait_for_ip_address: true
#     # wait_for_ip_address_timeout: 600
#   # delegate_to: localhost
#   register: deploy_vm
#   # tags:
#   #   - customattribut


## USING Content Library
- name: "VMWARE: Create the virtual machine for SNO"
  community.vmware.vmware_guest:
    hostname: "{{ vcenter_hostname }}"
    username: "{{ vcenter_username }}"
    password: "{{ vcenter_password }}"
    datacenter: "dc-home"
    folder: /dc-home/vm/openshift/
    name: "{{ cluster_name }}"
    state: powered-off
    guest_id: rhel9_64Guest
    # This is hostname of particular ESXi server on which user wants VM to be deployed
    # esxi_hostname: "{{ esxi_hostname }}"
    # customvalues:
    #   - key: disk.EnableUUID   # add the Advanced Configuration Parameter 
    #     value: TRUE
    disk:
    - size_gb: "{{ disk_size_gb }}"
      type: thin
      datastore: "{{ datastore }}"
    hardware:
      memory_mb: "{{ memory_mb }}"
      num_cpus: "{{ cpu_count }}"
    cdrom:
      - controller_type: sata
        controller_number: 0
        unit_number: 1
        state: present
        type: client
        # content_library: "{{ content_library_name }}"
        # library_iso: "{{ cluster_name }}.iso"
        # iso_path: "/{{ content_library_name }}/{{ cluster_name }}.iso"
        # iso_path: "[esx-datengrab] contentlib-caa1a910-0893-4e7d-8e11-80ea544cbed3/fef468a5-c07b-4f09-9fcb-c8399d07f7a3/agent.x86_64_2e0cbdb5-7c42-4765-8b41-78464ab56eb1.iso"
        iso_path: "[esx-datengrab] contentlib-caa1a910-0893-4e7d-8e11-80ea544cbed3/c10f2c3c-d71a-47ba-9149-ff5c89b17714/agent.x86_64_a2bb8826-bc8e-4e5e-a66f-e1c3c2d86e09.iso"
        # iso_path: "[contentLib] /iso-library/sno1.iso"
    networks:
    - name: "{{ network_name }}"
      device_type: vmxnet3
      mac: "{{ mac_address }}"
    # wait_for_ip_address: true
    # wait_for_ip_address_timeout: 600
  # delegate_to: localhost
  register: deploy_vm
  # tags:
  #   - customattribut

# INSERT ISO from Content Library
# govc device.cdrom.insert -vm sno1 library:/iso-library/sno1.iso
- name: "GOVC: INSERT ISO from Content Library"
  ansible.builtin.shell: "govc device.cdrom.insert -vm {{ cluster_name }} library:/{{ content_library_name }}/{{ cluster_name }}.iso"
  environment:
    GOVC_URL: "https://{{ vcenter_hostname }}/sdk"
    GOVC_USERNAME: "{{ vcenter_username }}"
    GOVC_PASSWORD: "{{ vcenter_password }}"
    GOVC_INSECURE: "0"  # Setzt SSL-Zertifikatüberprüfung außer Kraft, falls du selbstsignierte Zertifikate verwendes
    PATH: "/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:{{ base_dir }}downloads/"
  tags:
    - customattribut


# Set advanced configuration parameters via GOVC
# disk.EnableUUID=TRUE
- name: "GOVC: Set advanced configuration parameters via GOVC"
  ansible.builtin.shell: "govc vm.change -vm={{ cluster_name }} -e disk.EnableUUID=TRUE"
  environment:
    GOVC_URL: "https://{{ vcenter_hostname }}/sdk"
    GOVC_USERNAME: "{{ vcenter_username }}"
    GOVC_PASSWORD: "{{ vcenter_password }}"
    GOVC_INSECURE: "0"  # Setzt SSL-Zertifikatüberprüfung außer Kraft, falls du selbstsignierte Zertifikate verwendes
    PATH: "/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:{{ base_dir }}downloads/"
  tags:
    - customattribut

# Bootreihenfolge festlegen
- name: "VMWARE: Change virtual machine's boot order and related parameters"
  community.vmware.vmware_guest_boot_manager:
    hostname: "{{ vcenter_hostname }}"
    username: "{{ vcenter_username }}"
    password: "{{ vcenter_password }}"
    name: "{{ cluster_name }}"
    boot_delay: 2000
    enter_bios_setup: false
    boot_retry_enabled: true
    boot_retry_delay: 22300
    boot_firmware: efi
    secure_boot_enabled: true
    boot_order:
      - disk
      - cdrom
      - ethernet

# # ### END THE PLAYBOOK HERE
# - name: Stop the playbook here
#   ansible.builtin.meta: end_play
# # ### END THE PLAYBOOK HERE

- name: Set the state of a virtual machine to poweron
  community.vmware.vmware_guest_powerstate:
    hostname: "{{ vcenter_hostname }}"
    username: "{{ vcenter_username }}"
    password: "{{ vcenter_password }}"
    folder: "/{{ datacenter }}/vm/openshift"
    name: "{{ cluster_name }}"
    state: powered-on

# Zeige den Output für die DNSMASQ-Konfiguration an
- name: "Display DNS configuration reminder in better format"
  debug:
    msg:
      - "Bitte vergiss nicht deinen DNS-Server zu konfigurieren!"
      - "## {{ cluster_name }}"
      - "address=/.apps.{{ cluster_name }}.home.local/{{ ip_address }}"
      - "address=/api-int.{{ cluster_name }}.home.local/{{ ip_address }}"
      - "address=/api.{{ cluster_name }}.home.local/{{ ip_address }}"
      - "dhcp-host={{ deploy_vm.instance.hw_eth0.macaddress }},{{ ip_address }},{{ cluster_name }}"
