# tasks file for agend-based-sno
---
# Everything for a clean installation of the same cluster
- name: "CLEAN: Clean Cluster directories for a fresh installation"
  ansible.builtin.file:
    path: "{{ item }}"
    state: absent
  loop:
    - "{{ dir_ssh_keys }}"
    - "{{ dir_cluster }}"
    - "{{ dir_network }}"

# Remove ISO-File if exists, because of a new fresh installation
- name: "CLEAN: Delete the iso-file"
  ansible.builtin.file:
    path: "{{ dir_downloads }}{{ cluster_name }}.iso"
    state: absent

- name: "ENVIRONMENT: Create some base directories"
  ansible.builtin.file:
    path: "{{ item }}"
    state: directory
    mode: '0644'
  loop:
    - "{{ dir_base }}"
    - "{{ dir_base }}ssh-keys"
    - "{{ dir_base }}sno-clusters"
    - "{{ dir_base }}downloads"
    - "{{ dir_base }}certs"
    - "{{ dir_ssh_keys }}"
    - "{{ dir_cluster }}"
    - "{{ dir_network }}"
    - "/root/.cache/agent/image_cache/"

- name: "ENVIRONMENT: Create SSH directory if it does not exist"
  ansible.builtin.file:
    path: "{{ dir_ssh_keys }}"
    state: directory
    mode: '0755'

- name: "SSH-KEYS: Generate SSH key if not exists"
  ansible.builtin.command:
    cmd: "ssh-keygen -f {{ dir_ssh_keys }}/id_rsa_{{ cluster_name }} -N ''"
  args:
    creates: "{{ dir_ssh_keys }}/id_rsa_{{ cluster_name }}.pub"

- name: "SSH-KEYS: Check if SSH public key exists on remote server"
  ansible.builtin.stat:
    path: "{{ dir_ssh_keys }}/id_rsa_{{ cluster_name }}.pub"
  register: ssh_key_stat

- name: "SSH-KEYS: Fail if SSH public key does not exist"
  ansible.builtin.fail:
    msg: "The SSH public key {{ dir_ssh_keys }}/id_rsa_{{ cluster_name }}.pub was not found on the remote server."
  when: not ssh_key_stat.stat.exists

- name: "SSH-KEYS: Read SSH public key from remote server"
  ansible.builtin.slurp:
    src: "{{ dir_ssh_keys }}/id_rsa_{{ cluster_name }}.pub"
  register: ssh_key_content
  when: ssh_key_stat.stat.exists

- name: "SSH-KEYS: Decode SSH public key content"
  ansible.builtin.set_fact:
    ssh_public_key: "{{ ssh_key_content.content | b64decode | trim }}"
  when: ssh_key_stat.stat.exists

# Template install-config.yaml
- name: "OPENSHIFT: Template install-config.yaml in cluster directory"
  ansible.builtin.template:
    src: install-config.yaml.j2
    dest: "{{ dir_cluster }}/install-config.yaml"
    mode: '0644'

# Template agent-config.yaml
- name: "OPENSHIFT: Template agent-config.yaml in cluster directory"
  ansible.builtin.template:
    src: agent-config-with-network.yaml.j2
    dest: "{{ dir_cluster }}/agent-config.yaml"
    mode: '0644'

# Backup install-config.yaml
- name: "OPENSHIFT: Make a copy of install-config.yaml to shared directory (install-config-{{ cluster_name }}.yaml)"
  ansible.builtin.template:
    src: "install-config.yaml.j2"
    dest: "{{ dir_base }}/sno-clusters/install-config-{{ cluster_name }}.yaml"
    mode: '0644'

# Backup agent-config.yaml
- name: "OPENSHIFT: Make a copy of agent-config.yaml to shared directory (install-config-{{ cluster_name }}.yaml)"
  ansible.builtin.template:
    src: "agent-config-with-network.yaml.j2"
    dest: "{{ dir_base }}/sno-clusters/agent-config-{{ cluster_name }}.yaml"
    mode: '0644'


# Generate Zero-Touch-Provisioning YAML to cluster-dir
# openshift-install agent create cluster-manifests --dir <installation_directory>
- name: "OPENSHIFT-INSTALL: Create Cluster-Manifests-Directory for Zero-Touch-Provisioning"
  ansible.builtin.shell: "/usr/local/bin/openshift-install --dir={{ dir_base }}sno-clusters/{{ cluster_name }} agent create cluster-manifests"
  environment:
    PATH: "/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:{{ dir_base }}downloads/"

# INSERT ZTP Yaml-Files to customize the SNO-Installation
## HERE you can insert some cluster-configs, like ntp- or chronyd-configurations


# Create the ISO-Image
- name: "OPENSHIFT-INSTALL: Create Agent-Based-ISO"
  ansible.builtin.shell: "/usr/local/bin/openshift-install --dir={{ dir_base }}sno-clusters/{{ cluster_name }} agent create image"
  environment:
    PATH: "/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:{{ dir_base }}downloads/"


# Download Certificate from vCenter
- name: "BASTION: Download vCenter-Root-Certificates to Pod"
  ansible.builtin.get_url:
    url: "https://{{ vcenter_hostname }}/certs/download.zip"
    dest: "{{ dir_downloads }}download.zip"
    mode: '0600'
    validate_certs: false
  register: download_result

# Extract Root-Certificates
- name: "BASTION: Extract Root-Certificates to Bastion-Host certs-directory"
  ansible.builtin.unarchive:
    src: "{{ dir_downloads }}download.zip"
    dest: "{{ dir_certs }}"
    remote_src: true
  when: download_result is succeeded

# Copy root-cafile to truststore on Bastion-Host
- name: "BASTION: Copy all vcenter-rootca-certificate-files to the bastions truststore"
  ansible.builtin.copy:
    src: "{{ dir_entpackt }}"
    dest: "/etc/pki/ca-trust/source/anchors/"
    owner: root
    group: root
    mode: '0644'
    remote_src: true

# Refresh the truststore of the Bastion-Host
- name: "BASTION: Refresh Bastion-Host CA-Truststore"
  ansible.builtin.command: update-ca-trust
  changed_when: false

### VMWARE
# Delete VM
- name: "VMWARE: Delete an existing virtual machine, if exists"
  community.vmware.vmware_guest:
    hostname: "{{ vcenter_hostname }}"
    username: "{{ vcenter_username }}"
    password: "{{ vcenter_password }}"
    name: "{{ cluster_name }}"
    delete_from_inventory: true
    state: absent
    force: true

## Authorization for vmware Rest API
- name: Create a session using username and password
  uri:
    url: "https://{{ vcenter_hostname }}/rest/com/vmware/cis/session"
    method: POST
    validate_certs: false
    force_basic_auth: yes
    headers:
      Authorization: "Basic {{ (vcenter_username+':'+vcenter_password) | b64encode }}"
    status_code: 200
    return_content: yes
  register: session_id_res
  # no_log: yes
  run_once: true

- name: Save the session ID
  set_fact:
    session_id: "{{ session_id_res.json.value }}"
  run_once: true

## Get ID of the content library on the corresponding vmware server
- name: Get ID of Content Library
  uri:
    url: "https://{{ vcenter_hostname }}/rest/com/vmware/content/library?~action=find"
    method: POST
    validate_certs: false
    force_basic_auth: yes
    headers:
      vmware-api-session-id: "{{ session_id }}"
    body_format: json
    body:
      spec:
        name: "{{ content_library_name }}"
        type: LOCAL
    status_code: 200
    return_content: yes
  register: content_library_id_res

- name: Save the ID of the corresponding content library
  set_fact:
    content_library_id: "{{ content_library_id_res.json.value[0] }}"

- name: Get the ID of the old item with the same name
  uri:
    url: "https://{{ vcenter_hostname }}/rest/com/vmware/content/library/item?~action=find"
    method: POST
    validate_certs: false
    force_basic_auth: yes
    headers:
      vmware-api-session-id: "{{ session_id }}"
    body_format: json
    body:
      spec:
        name: "{{ cluster_name }}.iso"
        library_id: "{{ content_library_id }}"
    status_code: 200
    return_content: yes
  register: old_item_id_res
  vars:
    content_library_id: "{{ content_library_id_res.json.value[0] }}"

- name: Remove the old item with the same name from the content library
  uri:
    url: "https://{{ vcenter_hostname }}/rest/com/vmware/content/library/item/id:{{ old_item_id_res.json.value[0] }}"
    method: DELETE
    validate_certs: false
    force_basic_auth: yes
    headers:
      vmware-api-session-id: "{{ session_id }}"
    status_code: 200
    return_content: yes
  when: old_item_id_res.json.value[0] is defined

- name: Create an item in the content library
  uri:
    url: "https://{{ vcenter_hostname }}/rest/com/vmware/content/library/item"
    method: POST
    validate_certs: false
    force_basic_auth: yes
    headers:
      vmware-api-session-id: "{{ session_id }}"
    body_format: json
    body:
      create_spec:
        name: "{{ cluster_name }}.iso"
        type: "iso"
        library_id: "{{ content_library_id }}"
    status_code: 200
    return_content: yes
  register: content_library_item_id_res
  vars:
    content_library_id: "{{ content_library_id_res.json.value[0] }}"

- name: Save the ID of the content library item
  set_fact:
    content_library_item_id: "{{ content_library_item_id_res.json.value }}"

- name: Create an update session for the new content library item
  uri:
    url: "https://{{ vcenter_hostname }}/rest/com/vmware/content/library/item/update-session"
    method: POST
    validate_certs: false
    force_basic_auth: yes
    headers:
      vmware-api-session-id: "{{ session_id }}"
    body_format: json
    body:
      create_spec:
        library_item_id: "{{ content_library_item_id }}"
    status_code: 200
    return_content: yes
  register: update_session_id_res
  vars:
    content_library_item_id: "{{ content_library_item_id_res.json.value }}"

- name: Save the ID of the update session
  set_fact:
    update_session_id: "{{ update_session_id_res.json.value }}"

- name: Create a file in the new update session
  uri:
    url: "https://{{ vcenter_hostname }}/rest/com/vmware/content/library/item/updatesession/file/id:{{ update_session_id }}?~action=add"
    method: POST
    validate_certs: false
    force_basic_auth: yes
    headers:
      vmware-api-session-id: "{{ session_id }}"
    body_format: json
    body:
      file_spec:
        name: "{{ cluster_name }}.iso"
        source_type: PUSH
    status_code: 200
    return_content: yes
  register: file_upload_endpoint_res
  vars:
    update_session_id: "{{ update_session_id_res.json.value }}"

- name: Save the upload entpoint of the file
  set_fact:
    file_upload_endpoint: "{{ file_upload_endpoint_res.json.value.upload_endpoint.uri }}"

- name: Upload the ISO file
  uri:
    url: "{{ file_upload_endpoint_res.json.value.upload_endpoint.uri }}"
    method: PUT
    validate_certs: false
    force_basic_auth: yes
    headers:
      vmware-api-session-id: "{{ session_id }}"
    src: "{{ dir_cluster }}{{filename_agent_iso}}"
    remote_src: yes
    status_code: 200

- name: Confirm that file is uploaded
  uri:
    url: "https://{{ vcenter_hostname }}/rest/com/vmware/content/library/item/updatesession/file/id:{{ update_session_id }}?~action=get"
    method: POST
    validate_certs: false
    force_basic_auth: yes
    headers:
      vmware-api-session-id: "{{ session_id }}"
    body_format: json
    body:
      file_name: "{{ cluster_name }}.iso"
    status_code: 200
    return_content: yes
  register: file_status_res
  until: "file_status_res.json.value.status=='READY'"
  retries: 6
  delay: 5
  vars:
    update_session_id: "{{ update_session_id_res.json.value }}"

- name: Complete the update session
  uri:
    url: "https://{{ vcenter_hostname }}/rest/com/vmware/content/library/item/update-session/id:{{ update_session_id }}?~action=complete"
    method: POST
    validate_certs: false
    force_basic_auth: yes
    headers:
      vmware-api-session-id: "{{ session_id }}"
    status_code: 200
  vars:
    update_session_id: "{{ update_session_id_res.json.value }}"

# - name: Save the datastore of the content library
#   set_fact:
#     content_library_datastore: "{{ content_library_datastore }}"
#   run_once: true

- name: Save all ISO paths in the datastore of the content library
  set_fact:
    all_iso_paths_in_content_library_datastore: "{{ all_iso_paths_in_content_library_datastore|default({})|combine({cluster_name:iso_path_in_cl_datastore}) }}"
  vars:
    content_library_id: "{{ content_library_id_res.json.value[0] }}"
    content_library_item_id: "{{ content_library_item_id_res.json.value }}"
    update_session_id: "{{ update_session_id_res.json.value }}"
    iso_path_in_cl_datastore: "contentlib-{{ content_library_id }}/{{ content_library_item_id }}/{{ cluster_name }}_{{ update_session_id.split(':')[0] }}.iso"

- name: Save all content library item IDs
  set_fact:
    all_content_library_item_ids: "{{ all_content_library_item_ids|default({})|combine({cluster_name:content_library_item_id}) }}"
  vars:
    content_library_item_id: "{{ content_library_item_id_res.json.value }}"

## USING Content Library
- name: "VMWARE: Create the virtual machine for SNO"
  community.vmware.vmware_guest:
    hostname: "{{ vcenter_hostname }}"
    username: "{{ vcenter_username }}"
    password: "{{ vcenter_password }}"
    datacenter: "{{ datacenter }}"
    folder: "{{ vm_folder }}"
    name: "{{ cluster_name }}"
    state: powered-off
    guest_id: "{{ vm_guest_id }}"
    disk:
    - size_gb: "{{ disk_size_gb }}"
      type: thin
      datastore: "{{ datastore }}"
    hardware:
      memory_mb: "{{ memory_mb }}"
      num_cpus: "{{ cpu_count }}"
    cdrom:
      - controller_type: sata
        controller_number: 0
        unit_number: 1
        state: present
        type: iso
        # iso_path: "[esx-datengrab] contentlib-caa1a910-0893-4e7d-8e11-80ea544cbed3/fef468a5-c07b-4f09-9fcb-c8399d07f7a3/agent.x86_64_2e0cbdb5-7c42-4765-8b41-78464ab56eb1.iso"
        # iso_path: "[contentLib] /iso-library/sno1.iso"
        iso_path: "[{{ content_library_datastore }}] {{ all_iso_paths_in_content_library_datastore[cluster_name|lower] }}"
    networks:
    - name: "{{ network_name }}"
      device_type: vmxnet3
      mac: "{{ mac_address }}"
    # wait_for_ip_address: true
    # wait_for_ip_address_timeout: 600
  # delegate_to: localhost
  register: deploy_vm

# Set advanced configuration parameters via GOVC
# disk.EnableUUID=TRUE
- name: "GOVC: Set advanced configuration parameters via GOVC"
  ansible.builtin.shell: "govc vm.change -vm={{ cluster_name }} -e disk.EnableUUID=TRUE"
  environment:
    GOVC_URL: "https://{{ vcenter_hostname }}/sdk"
    GOVC_USERNAME: "{{ vcenter_username }}"
    GOVC_PASSWORD: "{{ vcenter_password }}"
    GOVC_INSECURE: "0"  # Setzt SSL-Zertifikatüberprüfung außer Kraft, falls du selbstsignierte Zertifikate verwendes
    PATH: "/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:{{ dir_base }}downloads/"
  tags:
    - customattribut

# Bootreihenfolge festlegen
- name: "VMWARE: Change virtual machine's boot order and related parameters"
  community.vmware.vmware_guest_boot_manager:
    hostname: "{{ vcenter_hostname }}"
    username: "{{ vcenter_username }}"
    password: "{{ vcenter_password }}"
    name: "{{ cluster_name }}"
    boot_delay: 2000
    enter_bios_setup: false
    boot_retry_enabled: true
    boot_retry_delay: 22300
    boot_firmware: efi
    secure_boot_enabled: true
    boot_order:
      - disk
      - cdrom
      - ethernet

# # ### END THE PLAYBOOK HERE
# - name: Stop the playbook here
#   ansible.builtin.meta: end_play
# # ### END THE PLAYBOOK HERE

- name: Set the state of a virtual machine to poweron
  community.vmware.vmware_guest_powerstate:
    hostname: "{{ vcenter_hostname }}"
    username: "{{ vcenter_username }}"
    password: "{{ vcenter_password }}"
    folder: "{{ vm_folder }}"
    name: "{{ cluster_name }}"
    state: powered-on

# Zeige den Output für die DNSMASQ-Konfiguration an
- name: "Display DNS configuration reminder in better format"
  debug:
    msg:
      - "Bitte vergiss nicht deinen DNS-Server zu konfigurieren!"
      - "## {{ cluster_name }}"
      - "address=/.apps.{{ cluster_name }}.home.local/{{ ip_address }}"
      - "address=/api-int.{{ cluster_name }}.home.local/{{ ip_address }}"
      - "address=/api.{{ cluster_name }}.home.local/{{ ip_address }}"
      - "dhcp-host={{ deploy_vm.instance.hw_eth0.macaddress }},{{ ip_address }},{{ cluster_name }}"

# # # ### END THE PLAYBOOK HERE
# - name: Stop the playbook here
#   ansible.builtin.meta: end_play
# # # ### END THE PLAYBOOK HERE